/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/*  »Project«   Teikitu Gaming System (TgS) (∂)
    »File«      TgS Collision - F - Capsule-Triangle.c_inc
    »Author«    Andrew Aye (mailto: andrew.aye@teikitu.com, https://www.andrew.aye.page)
    »Version«   5.16 / »GUID« 015482FC-A4BD-4E1C-AE49-A30E5728D73A */
/*  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */
/*  Copyright: © 2002-2020, Andrew Aye.  All Rights Reserved.
    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
    the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details. You should have received a copy of the
    GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */

#if !defined (ENABLE_RELOAD_GUARD)
    #define ENABLE_RELOAD_GUARD
    #if !defined(TEMPLATE__TYPE_SIZE)
        #define TEMPLATE__TYPE_SIZE 32
        #include __FILE__
        #undef TEMPLATE__TYPE_SIZE
        #define TEMPLATE__TYPE_SIZE 64
    #endif
    #undef ENABLE_RELOAD_GUARD
#endif

#include "TgS COMMON/TgS Common - Base - Defines [Template] [Math].h_inc"


/* == Collision ================================================================================================================================================================== */

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */
/*  File Local Functions                                                                                                                                                           */
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */

static TgRESULT                             FCN_VO(tgCO_FI_ST_Penetrate_Parallel_CP)(VEC_OBJ_T(STg2_CO_Packet,PC), VEC_OBJ_T(TgSTRI,CPC), VEC_OBJ_T(TgTUBE,CPC));
static TgRESULT                             FCN_VO(tgCO_FI_ST_Penetrate_Parallel_NoClip_CP)(VEC_OBJ_T(STg2_CO_Packet,PC), VEC_OBJ_T(TgSTRI,CPC), VEC_OBJ_T(TgTUBE,CPC));
static TgRESULT                             FCN_VO(tgCO_FI_ST_Penetrate_Sphere_Cap_CP)( VEC_OBJ_T(STg2_CO_Packet,PC), VEC_OBJ_T(TgTUBE,CPC), VEC_OBJ_T(TgSTRI,CPC), VAR_T(C), VEC_T(1,CPC) );




/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */
/*  Public Functions                                                                                                                                                               */
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */

/* ---- FCN_VO(tgCO_F_ST_Penetrate_CP) ------------------------------------------------------------------------------------------------------------------------------------------- */
/* Input:  psPacket: The current series of contact points for this query-series, and contact generation parameters.                                                                */
/* Input:  psST0: Space Triangle primitive                                                                                                                                         */
/* Input:  psCP0: Capsule primitive - contact points are generated on this primitive                                                                                               */
/* Output: psPacket: Points of penetration between the two primitives are added to it                                                                                              */
/* Return: Result Code                                                                                                                                                             */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgRESULT FCN_VO(tgCO_F_ST_Penetrate_CP)(VEC_OBJ_T(STg2_CO_Packet,PC) psPacket, VEC_OBJ_T(TgSTRI,CPC) psST0, VEC_OBJ_T(TgTUBE,CPC) psCP0)
{
    TgPARAM_CHECK(FCN_VO(tgGM_TB_Is_Valid)(psCP0) && FCN_VO(tgGM_ST_Is_Valid)(psST0));

    if (0 == psPacket->m_niMaxContact || psPacket->m_niContact >= psPacket->m_niMaxContact || nullptr == psPacket->m_psContact)
    {
        return (KTgE_FAIL);
    }
    else
    {
        /* Primitive Culling - Set of criteria required for the primitive to be considered penetrating the triangle. */

        VEC_T(1,C)                          vK0 = FCN_V(tgMH_SUB)(&psCP0->m_vOrigin, psST0->m_sCT.m_sET.m_sPT.m_avPoint);
        VAR_T(C)                            fDS_N = FCN_V(tgMH_DOT)(&psST0->m_sCT.m_sET.m_sPT.m_vNormal, &vK0);
        VAR_T(C)                            fEX_N = FCN_V(tgMH_DOT)(&psST0->m_sCT.m_sET.m_sPT.m_vNormal, &psCP0->m_vHAX);
        VAR_T(C)                            fS0_N = fDS_N - fEX_N;
        VAR_T(C)                            fS1_N = fDS_N + fEX_N;
        VEC_OBJ_T(STg2_CO_Contact,P)        psContact;;
        VAR_T()                             fDepth;
        VAR_T()                             fCT0, fCT1, fCP0;
        TgBOOL                              bResultCreated = false;
        TgRESULT                            iResult;
        VAR_T()                             fDistSq;

        /*TgDEBUG_COLLISION_TRIANGLE_CREATEID( iDBG_TriID, psST0, etgDEBUG_COLLISION_ENTERFCN ); */

        if ((fS0_N > psCP0->m_fRadius && fS1_N > psCP0->m_fRadius) || (fS0_N < TYPE_K(0) && fS1_N < TYPE_K(0)))
        {
            /* Either both of the capsule's end points are below the plane or more than radius above the plane. */

            return (KTgE_NO_INTERSECT);
        };

        /*TgDEBUG_COLLISION_TRIANGLE( iDBG_TriID, etgDEBUG_COLLISION_PASSED_REJECT ); */

        /* Check the projection of the capsule primary axis against the triangle normal. If its near zero (ie the two vectors are near perpendicular), the capsule must */
        /* be near-parallel to the triangle. In this case the method of closest proximity will not work, and the axis segment will instead be clipped to triangle space. */

        if (FCN_F(tgCM_NR0)(fEX_N))
        {
            /* Since the capsule is near-parallel to the triangle itself, in terms of the contact surface, it is no longer different than a regular tube.  Execute that */
            /* primitive's parallel case to generate the contact points. */
            if (TgFAILED( iResult = FCN_VO(tgCO_FI_ST_Penetrate_Parallel_CP)(psPacket, psST0, psCP0) ))
            {
                return (iResult);
            };
        };

        /*TgDEBUG_COLLISION_TRIANGLE( iDBG_TriID, etgDEBUG_COLLISION_CODE2 ); */

        /* Find the minimal distance and points of closest proximity for the capsule's axis and the triangle. */

        fDistSq = FCN_VO(tgCO_F_ST_ParamSq_SG)(&fCT0, &fCT1, &fCP0, psST0, &psCP0->m_sAX);

        /* Intersection is impossible if the minimal distance is greater than the capsule's radius. */

        if (fDistSq > psCP0->m_fRadiusSq)
        {
            return (KTgE_NO_INTERSECT);
        };

        /* If the closest point on the triangle to the capsule's axis is not on a valid edge, then the generated axis is ignored and the system falls back to creating */
        /* contacts for the two spherical caps. */

        if (!FCN_F(tgCM_NR0)(fCP0) && !FCN_F(tgCM_NR1)(fCP0) && !FCN_VO(tgGM_ST_Is_Point_Culled)(psST0, fCT0, fCT1))
        {
            /* Create contacts only for the tube portion of the capsule. */
            /* Create the two points of closest proximity and the corresponding vector difference between the two. */

            VEC_T(1,C)                          vK1 = FCN_V(tgMH_MUL_SV)(fCT0, psST0->m_sCT.m_sET.m_avEdge + 0);
            VEC_T(1,C)                          vK2 = FCN_V(tgMH_MUL_SV)(fCT1, psST0->m_sCT.m_sET.m_avEdge + 2);
            VEC_T(1,C)                          vK4 = FCN_V(tgMH_MUL_SV)(fCP0, &psCP0->m_sAX.m_vDirN);
            VEC_T(1,C)                          vK5 = FCN_V(tgMH_SUB)(&vK1, &vK2);
            VEC_T(1,C)                          vCP0 = FCN_V(tgMH_ADD)(&psCP0->m_sAX.m_vOrigin, &vK4);
            VEC_T(1,C)                          vCT1 = FCN_V(tgMH_ADD)(psST0->m_sCT.m_sET.m_sPT.m_avPoint, &vK5);
            VEC_T(1,C)                          vK3 = FCN_V(tgMH_SUB)(&vCP0, psST0->m_sCT.m_sET.m_sPT.m_avPoint);
            VAR_T(C)                            fTest = FCN_V(tgMH_DOT)(&vK3, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);
            VEC_T(1,C)                          vK6 = FCN_V(tgMH_SUB)(&vCP0, &vCT1);
            VEC_T(1,C)                          vK7 = FCN_V(tgMH_SUB)(&vCT1, &vCP0);
            VEC_T(1)                            vNormal = fTest > TYPE_K(0) ? vK6 : vK7;

            /* Calculate the resultant penetration depth at this point. */

            VAR_T(C)                            fDist = fTest > TYPE_K(0) ? FCN_F(tgPM_SQRT)(fDistSq) : -FCN_F(tgPM_SQRT)(fDistSq);
            TgBOOL                              bUseNormal = fDistSq > VAR_K(KTgEPS);

            fDepth = fDist >= psCP0->m_fRadius ? TYPE_K(0) : psCP0->m_fRadius - fDist;

            /*  Check to see if the normal of intersection should be replaced by the triangle's normal.  This is done to reduce floating point noise in the system where */
            /* near-normal results are returned.  By forcing it to the triangle's normal, extraneous rotations are minimized. The other possibility is that the capsule's */
            /* segment intersects the triangle itself, thus, requiring the selection of the triangle's normal for the intersection. */

            if (bUseNormal)
            {
                vNormal = FCN_V(tgMH_NORM)(&vNormal);

                /* Check to see if the resultant normal is near that of the triangle's.  If they are close then use the triangle's normal to help further reduce */
                /* floating point noise. */
                bUseNormal = FCN_F(tgCM_NR0)(FCN_V(tgMH_DOT)(&vNormal, &psST0->m_sCT.m_sET.m_sPT.m_vNormal) - TYPE_K(1));
            };

            /* Create contact point. */

            psContact = psPacket->m_psContact + psPacket->m_niContact;

            {
                VEC_T(1,C)                          vK8 = bUseNormal ? vNormal : psST0->m_sCT.m_sET.m_sPT.m_vNormal;
                VEC_T(1,C)                          vK9 = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &vK8);

                psContact->m_vS0 = FCN_V(tgMH_SUB)(&vCT1, &vK9);
                psContact->m_vN0 = vK8;
                psContact->m_fT0 = TYPE_K(0);
                psContact->m_fDepth = fDepth;

                ++psPacket->m_niContact;
                bResultCreated = true;
            };
        };

        {
            VEC_T(1,C)                          vKA = FCN_V(tgMH_SUB)(&psCP0->m_vOrigin, &psCP0->m_vHAX);

            iResult = FCN_VO(tgCO_FI_ST_Penetrate_Sphere_Cap_CP)(psPacket, psCP0, psST0, fS0_N, &vKA);
            switch (iResult)
            {
                case KTgE_MAX_CONTACTS:
                    return (KTgE_MAX_CONTACTS);
                default:
                    bResultCreated |= TgSUCCEEDED( iResult );
            };
        }

        {
            VEC_T(1,C)                          vKB = FCN_V(tgMH_ADD)(&psCP0->m_vOrigin, &psCP0->m_vHAX);

            iResult = FCN_VO(tgCO_FI_ST_Penetrate_Sphere_Cap_CP)(psPacket, psCP0, psST0, fS1_N, &vKB);
            switch (iResult)
            {
                case KTgE_MAX_CONTACTS:
                    return (KTgE_MAX_CONTACTS);
                default:
                    bResultCreated |= TgSUCCEEDED( iResult );
            };
        }

        /*TgDEBUG_COLLISION_TRIANGLE( iDBG_TriID, bResultCreated ? etgDEBUG_COLLISION_FINAL : etgDEBUG_COLLISION_CODE4 ); */

        return (bResultCreated ? KTgS_OK : KTgE_NO_INTERSECT);
    };
}


/* ---- FCN_VO(tgCO_F_CP_Test_Sweep_ST) ------------------------------------------------------------------------------------------------------------------------------------------ */
/* Input:  psPacket: The current series of contact points for this query-series, and contact generation parameters.                                                                */
/* Input:  psST0: Space Triangle primitive                                                                                                                                         */
/* Input:  psCP0: Capsule primitive                                                                                                                                                */
/* Input:  vUDT: Normalized direction of displacement for the swept primitive (capsule)                                                                                            */
/* Input:  fDT: Length of displacement for the swept primitive                                                                                                                     */
/* Return: True if the two primitives are in contact at anytime during the sweep                                                                                                   */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgBOOL FCN_VO(tgCO_F_CP_Test_Sweep_ST)( VEC_OBJ_T(TgSTRI,CPC) psST0, VEC_OBJ_T(TgTUBE,CPC) psCP0, VEC_T(1,CPC) pvUDT, VAR_T(C) fDT )
{
    VAR_T(C)                            fUDT_CA = FCN_V(tgMH_DOT)(pvUDT, &psCP0->m_vU_HAX);
    VEC_T(1,C)                          vDT = FCN_V(tgMH_MUL_VS)(pvUDT, fDT);
    VEC_OBJ_T(TgPARALLELOGRAM)          sSweptCapsule;
    VAR_T()                             fT0, fT1, fT2;
    VEC_T(1)                            vNM;

    TgERROR( FCN_VO(tgGM_TB_Is_Valid)( psCP0 ) && FCN_VO(tgGM_ST_Is_Valid)( psST0 ) );

    if (FCN_F(tgCM_NR0)(fUDT_CA - TYPE_K(1))) /* Delta vector is parallel to the capsule axis. */
    {
        VEC_T(1,C)                          vK0 = FCN_V(tgMH_ADD)( &psCP0->m_sAX.m_vDirN, &vDT );

        return (FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &psCP0->m_sAX.m_vOrigin, &vK0 ) < psCP0->m_fRadiusSq);
    };

    if (FCN_F(tgCM_NR0)(fUDT_CA + TYPE_K(1))) /* Delta vector is parallel to the capsule axis. */
    {
        VEC_T(1,C)                          vK1 = FCN_V(tgMH_ADD)( &psCP0->m_sAX.m_vOrigin, &vDT );
        VEC_T(1,C)                          vK2 = FCN_V(tgMH_SUB)( &psCP0->m_sAX.m_vDirN, &vDT );

        return (FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &vK1, &vK2 ) < psCP0->m_fRadiusSq);
    }
    else
    {
        /* Test to see if the swept capsule (represented by the edges of a parallelogram) comes within range of the triangle. */
        VEC_T(1,C)                          vK3 = FCN_V(tgMH_ADD)( &psCP0->m_sAX.m_vOrigin, &vDT );
        VEC_T(1,C)                          vK4 = FCN_V(tgMH_ADD)( &psCP0->m_sAX.m_vOrigin, &psCP0->m_sAX.m_vDirN );
        if (
            FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &psCP0->m_sAX.m_vOrigin, &psCP0->m_sAX.m_vDirN ) < psCP0->m_fRadiusSq ||
            FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &psCP0->m_sAX.m_vOrigin, &vDT ) < psCP0->m_fRadiusSq ||
            FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &vK3, &psCP0->m_sAX.m_vDirN ) < psCP0->m_fRadiusSq ||
            FCN_VO(tgCO_FI_ST_ParamSq_LR11)( &fT0, &fT1, &fT2, psST0, &vK4, &vDT ) < psCP0->m_fRadiusSq
        )
        {
            return (true);
        };
    };

    /* Test to see if the triangle ever comes within range of the swept capsule (represented by a parallelogram) */

    vNM = FCN_V(tgMH_UCX)( &psCP0->m_sAX.m_vDirN, &vDT );
    FCN_VO(tgGM_PE_Init)( &sSweptCapsule, &psCP0->m_sAX.m_vOrigin, &psCP0->m_sAX.m_vDirN, &vDT, &vNM );

    if (
        FCN_VO(tgCO_FI_PE_Test_LR11)( &sSweptCapsule, psST0->m_sCT.m_sET.m_sPT.m_avPoint + 0, psST0->m_sCT.m_sET.m_avEdge + 0 ) ||
        FCN_VO(tgCO_FI_PE_Test_LR11)( &sSweptCapsule, psST0->m_sCT.m_sET.m_sPT.m_avPoint + 0, psST0->m_sCT.m_sET.m_avEdge + 1 ) ||
        FCN_VO(tgCO_FI_PE_Test_LR11)( &sSweptCapsule, psST0->m_sCT.m_sET.m_sPT.m_avPoint + 1, psST0->m_sCT.m_sET.m_avEdge + 2 )
    )
    {
        return (true);
    };

    return (false);
}




/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */
/*  File Local Functions                                                                                                                                                           */
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.- */

/* ---- FCN_VO(tgCO_FI_ST_Penetrate_Parallel_CP) --------------------------------------------------------------------------------------------------------------------------------- */
/* Input:  psPacket: The current series of contact points for this query-series, and contact generation parameters.                                                                */
/* Input:  psST0: Space Triangle primitive                                                                                                                                         */
/* Input:  psCP0: Capsule primitive - contact points are generated on this primitive                                                                                               */
/* Output: psPacket: Points of penetration between the two primitives are added to it                                                                                              */
/* Return: Result Code                                                                                                                                                             */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
static TgRESULT FCN_VO(tgCO_FI_ST_Penetrate_Parallel_CP)( VEC_OBJ_T(STg2_CO_Packet,PC) psPacket, VEC_OBJ_T(TgSTRI,CPC) psST0, VEC_OBJ_T(TgTUBE,CPC) psCP0 )
{
    /* The capsule is, within tolerance, parallel to the triangle plane.  The format of the surface of contact is therefore definitively a longitudinal surface - */
    /* stretching along the capsule.  It is necessary to trap this specific case since the non-parallel case will use a closest point algorithm derivative.  Using that */
    /* system will cause a varying and random selection of one of the capsule extremities - which would then introduce a time varying reaction force resulting in */
    /* an unrealistic rocking motion or could potentially feed existing rotations.  Keep in mind that since the selection process would be at the extremities, an */
    /* unbalanced moment would be added into the simulation which could be very problematic. */

    VAR_T()                             fT0, fT1;

    if (TgFAILED( FCN_VO(tgCO_F_ST_Clip_Param_SG)(&fT0, &fT1, psST0, &psCP0->m_sAX) ))
    {
        /* The capsule axis does not exist anywhere in the triangle's normal extruded space.  A specific contact routine will create the contacts between the triangle */
        /* edge and the capsule. */

        return (FCN_VO(tgCO_FI_ST_Penetrate_Parallel_NoClip_CP)(psPacket, psST0, psCP0));
    }
    else
    {
        VEC_T(1,C)                          vK0 = FCN_V(tgMH_MUL_SV)(fT0, &psCP0->m_sAX.m_vDirN);
        VEC_T(1,C)                          vK1 = FCN_V(tgMH_MUL_SV)(fT1, &psCP0->m_sAX.m_vDirN);
        VEC_T(1,C)                          vP0 = FCN_V(tgMH_ADD)(&psCP0->m_sAX.m_vOrigin, &vK0);
        VEC_T(1,C)                          vP1 = FCN_V(tgMH_ADD)(&psCP0->m_sAX.m_vOrigin, &vK1);

        VEC_T(1,C)                          vK2 = FCN_V(tgMH_SUB)(&vP0, psST0->m_sCT.m_sET.m_sPT.m_avPoint);
        VEC_T(1,C)                          vK3 = FCN_V(tgMH_SUB)(&vP1, psST0->m_sCT.m_sET.m_sPT.m_avPoint);
        VAR_T(C)                            fDist0 = psCP0->m_fRadius - FCN_V(tgMH_DOT)(&vK2, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);
        VAR_T(C)                            fDist1 = psCP0->m_fRadius - FCN_V(tgMH_DOT)(&vK3, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);

        VEC_OBJ_T(STg2_CO_Contact,P)        psContact;;

        if (fDist0 >= TYPE_K(0))
        {
            if (psPacket->m_niContact >= psPacket->m_niMaxContact)
            {
                return (KTgE_MAX_CONTACTS);
            }
            else
            {
                VEC_T(1,C) vK4 = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);

                psContact = psPacket->m_psContact + psPacket->m_niContact;

                psContact->m_vS0 = FCN_V(tgMH_SUB)(&vP0, &vK4);
                psContact->m_vN0 = psST0->m_sCT.m_sET.m_sPT.m_vNormal;
                psContact->m_fT0 = TYPE_K(0);
                psContact->m_fDepth = fDist0;

                ++psPacket->m_niContact;
            };
        };

        if (fDist1 >= TYPE_K(0))
        {
            if (psPacket->m_niContact >= psPacket->m_niMaxContact)
            {
                return (KTgE_MAX_CONTACTS);
            }
            else
            {
                VEC_T(1,C) vK5 = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);

                psContact = psPacket->m_psContact + psPacket->m_niContact;

                psContact->m_vS0 = FCN_V(tgMH_SUB)(&vP1, &vK5);
                psContact->m_vN0 = psST0->m_sCT.m_sET.m_sPT.m_vNormal;
                psContact->m_fT0 = TYPE_K(0);
                psContact->m_fDepth = fDist1;

                ++psPacket->m_niContact;
            };
        };

        return (fDist0 >= TYPE_K(0) || fDist1 >= TYPE_K(0) ? KTgS_OK : KTgE_NO_INTERSECT);
    }
}


/* ---- FCN_VO(tgCO_FI_ST_Penetrate_Parallel_NoClip_CP) -------------------------------------------------------------------------------------------------------------------------- */
/*  -- Internal Function --                                                                                                                                                        */
/* Input:  psPacket: The current series of contact points for this query-series, and contact generation parameters.                                                                */
/* Input:  psST0: Space Triangle primitive                                                                                                                                         */
/* Input:  psCP0: Capsule primitive - contact points are generated on this primitive                                                                                               */
/* Output: psPacket: Points of penetration between the two primitives are added to it                                                                                              */
/* Return: Result Code                                                                                                                                                             */
/*                                                                                                                                                                                 */
/* Used when the capsule is parallel to the triangle plane, and the axis lies outside of the normal extruded triangle space.                                                       */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
static TgRESULT FCN_VO(tgCO_FI_ST_Penetrate_Parallel_NoClip_CP)( VEC_OBJ_T(STg2_CO_Packet,PC) psPacket, VEC_OBJ_T(TgSTRI,CPC) psST0, VEC_OBJ_T(TgTUBE,CPC) psCP0 )
{
    /* It is now known that the capsule axis does not pass through the triangle normal extruded space.  However, contact can still occur because the triangle's edge */
    /* and/or vertices can penetrate the capsule resulting in a non-planar directed normal.  Special care must be taken into account if the resulting penetrating feature */
    /* is parallel to the capsule. */

    /* Method: Find the nearest triangle feature to the capsule.  If the feature is not enabled then its assumed that the resulting adjoined primitives will produce the */
    /* required contacts and the feature can be ignored and the procedure terminated.  No matter the type of feature found the resulting edge or connected edges should */
    /* be tested to see if they are parallel to the capsule axis so that multiple points of contact can be created.  The secondary contact point should also be tested */
    /* for feature reduction. */

    VEC_T(1,C)                          vS0 = FCN_V(tgMH_SUB)(&psCP0->m_vOrigin, &psCP0->m_vHAX);
    VEC_T(1,C)                          vS1 = FCN_V(tgMH_ADD)(&psCP0->m_vOrigin, &psCP0->m_vHAX);
    VEC_T(1,C)                          vAX = psCP0->m_sAX.m_vDirN;
    VAR_T(C)                            fAX_AX = FCN_V(tgMH_LSQ)(&vAX);

    TgSINT_F32_C                        niContact = psPacket->m_niContact;
    VEC_OBJ_T(STg2_CO_Contact,P)        psContact;;

    for (TgRSIZE uiEdge = 0; uiEdge < 3; ++uiEdge)
    {
        /* Test each vertex individually to prevent the creation of duplicate contacts from the edge routines (shared vertices). */
        if (FCN_VO(tgGM_ST_Test_Point)(psST0, uiEdge))
        {
            FCN_VO(tgCO_F_VT_Penetrate_CP)(psPacket, psST0->m_sCT.m_sET.m_sPT.m_avPoint + uiEdge, psCP0);
        };

        if (!FCN_VO(tgGM_ST_Test_Edge)(psST0, uiEdge)) /* Only collide with those edges marked as valid */
        {
            continue;
        }
        else
        {
            /* Contacts are created only for those edges where the capsule exists entirely in the positive half-space and at least minimally exists in the feature space. */

            VEC_T(1,C)                          vEP = psST0->m_sCT.m_sET.m_sPT.m_avPoint[uiEdge];
            VEC_T(1,C)                          vEN = psST0->m_avPlane[uiEdge].m_vNormal;
            VEC_T(1,C)                          vET = psST0->m_sCT.m_sET.m_avEdge[uiEdge];

            VEC_T(1,C)                          vK0 = FCN_V(tgMH_SUB)(&vS0, &vEP);
            VEC_T(1,C)                          vK1 = FCN_V(tgMH_SUB)(&vS1, &vEP);
            VEC_T(1,C)                          vK2 = FCN_V(tgMH_SUB)(&vS0, &vEP);
            VEC_T(1,C)                          vK3 = FCN_V(tgMH_SUB)(&vS1, &vEP);

            VAR_T(C)                            fDist0 = FCN_V(tgMH_DOT)(&vK0, &vET);
            VAR_T(C)                            fDist1 = FCN_V(tgMH_DOT)(&vK1, &vET);
            VAR_T(C)                            fTest0 = FCN_V(tgMH_DOT)(&vK2, &vEN);
            VAR_T(C)                            fTest1 = FCN_V(tgMH_DOT)(&vK3, &vEN);

            VAR_T(C)                            fET_ET = FCN_V(tgMH_LSQ)(&vET);

            if (
                (fDist0 < TYPE_K(0) && fDist1 < TYPE_K(0)) ||
                (fDist0 > fET_ET   && fDist1 > fET_ET) ||
                (fTest0 < TYPE_K(0) && fTest1 < TYPE_K(0))
            )
            {
                continue;
            };

            /* The capsule is known to be on the positive side of the edge normal half-space and is captured passing through it. */

            if (FCN_F(tgCM_NR0)(FCN_V(tgMH_DOT)(&psCP0->m_vU_HAX, &vEN)))
            {
                /* The capsule axis is parallel to the edge */

                VEC_T(1,C)                          vDS = FCN_V(tgMH_SUB)(&vEP, &vS0);

                /*                                  Projection Values */
                VAR_T(C)                            fAX_ET = FCN_V(tgMH_DOT)(&vAX, &vET);
                VAR_T(C)                            fDS_AX = FCN_V(tgMH_DOT)(&vDS, &vAX);
                VAR_T(C)                            fDS_ET = -FCN_V(tgMH_DOT)(&vDS, &vET);

                VAR_T(C)                            fDE_AX = fDS_AX + fAX_ET; /* vDE = vEP+vET, fDE_ET = (vEP+vET - vS0)•vAX */
                VAR_T(C)                            fDF_ET = fAX_ET - fDS_ET; /* vDF = vS0+vAX, fDF_ET = (vS0+vAX - vEP)•vET */

                if (
                    (fAX_ET >= TYPE_K(0) && (fDE_AX < TYPE_K(0) || fDS_AX > TYPE_K(1))) ||
                    (fAX_ET <= TYPE_K(0) && (fDS_AX < TYPE_K(0) || fDE_AX > TYPE_K(1)))
                )
                {
                    continue;
                }
                else
                {
                    VAR_T(C)                            fTA = fDS_AX / fAX_AX;
                    VAR_T(C)                            fTC = fDE_AX / fAX_AX;

                    /* Point 0 of segment 0 if contained in segment 1, otherwise if segments are mutually directed point 0 of segment 1, else point 1 of segment 1. */
                    VAR_T(C)                            fK0 = FCN_F(tgPM_FSEL)(fET_ET - fDS_ET, TYPE_K(1), -TYPE_K(1));
                    VAR_T(C)                            fF0 = FCN_F(tgPM_FSEL)(fDS_ET, fK0, -TYPE_K(1));
                    VAR_T(C)                            fT0 = FCN_F(tgPM_FSEL)(fF0, TYPE_K(0), FCN_F(tgPM_FSEL)(fAX_ET, fTA, fTC));
                    VAR_T(C)                            fK1 = FCN_F(tgPM_FSEL)(fAX_ET, TYPE_K(0), TYPE_K(1));
                    VAR_T(C)                            fT1 = FCN_F(tgPM_FSEL)(fF0, (fDS_ET / fET_ET), fK1);

                    /* Point 1 of segment 0 if contained in segment 1, otherwise if segments are mutually directed point 1 of segment 1, else point 0 of segment 1. */
                    VAR_T(C)                            fK2 = FCN_F(tgPM_FSEL)(fET_ET - fDF_ET, TYPE_K(1), -TYPE_K(1));
                    VAR_T(C)                            fF1 = FCN_F(tgPM_FSEL)(fDF_ET, fK2, -TYPE_K(1));
                    VAR_T(C)                            fT2 = FCN_F(tgPM_FSEL)(fF1, TYPE_K(1), FCN_F(tgPM_FSEL)(fAX_ET, fTC, fTA));
                    VAR_T(C)                            fK3 = FCN_F(tgPM_FSEL)(fAX_ET, TYPE_K(1), TYPE_K(0));
                    VAR_T(C)                            fT3 = FCN_F(tgPM_FSEL)(fF1, (fDF_ET / fET_ET), fK3);

                    VEC_T(1,C)                          vK4 = FCN_V(tgMH_MUL_SV)(fT0, &vAX);
                    VEC_T(1,C)                          vK5 = FCN_V(tgMH_MUL_SV)(fT1, &vET);
                    VEC_T(1,C)                          vK6 = FCN_V(tgMH_MUL_SV)(fT2, &vAX);
                    VEC_T(1,C)                          vK7 = FCN_V(tgMH_MUL_SV)(fT3, &vET);
                    VEC_T(1,C)                          vP0 = FCN_V(tgMH_ADD)(&vS0, &vK4);
                    VEC_T(1,C)                          vP1 = FCN_V(tgMH_ADD)(&vEP, &vK5);
                    VEC_T(1,C)                          vK8 = FCN_V(tgMH_SUB)(&vP0, &vP1);
                    VEC_T(1,C)                          vP2 = FCN_V(tgMH_ADD)(&vS0, &vK6);
                    VEC_T(1,C)                          vP3 = FCN_V(tgMH_ADD)(&vEP, &vK7);
                    VEC_T(1,C)                          vK9 = FCN_V(tgMH_SUB)(&vP2, &vP3);

                    VEC_T(1)                            vNM;
                    VAR_T()                             fTM;

                    TgERROR( fT0 >= TYPE_K(0) && fT0 <= TYPE_K(1) );
                    TgERROR( fT1 >= TYPE_K(0) && fT1 <= TYPE_K(1) );
                    TgERROR( fT2 >= TYPE_K(0) && fT2 <= TYPE_K(1) );
                    TgERROR( fT3 >= TYPE_K(0) && fT3 <= TYPE_K(1) );

                    vNM = FCN_V(tgMH_NORM_LEN)(&fTM, &vK8);

                    if (fTM < psCP0->m_fRadius && !FCN_F(tgCM_NR0)(fT1) && !FCN_F(tgCM_NR1)(fT1))
                    {
                        if (psPacket->m_niContact >= psPacket->m_niMaxContact)
                        {
                            return (KTgE_MAX_CONTACTS);
                        }
                        else
                        {
                            VEC_T(1,C)                          vKA = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &vNM);

                            psContact = psPacket->m_psContact + psPacket->m_niContact;

                            psContact->m_vS0 = FCN_V(tgMH_SUB)(&vP0, &vKA);
                            psContact->m_vN0 = vNM;
                            psContact->m_fT0 = TYPE_K(0);
                            psContact->m_fDepth = psCP0->m_fRadius - fTM;

                            ++psPacket->m_niContact;
                        };
                    };

                    vNM = FCN_V(tgMH_NORM_LEN)(&fTM, &vK9);

                    if (fTM < psCP0->m_fRadius && !FCN_F(tgCM_NR0)(fT3) && !FCN_F(tgCM_NR1)(fT3))
                    {
                        if (psPacket->m_niContact >= psPacket->m_niMaxContact)
                        {
                            return (KTgE_MAX_CONTACTS);
                        }
                        else
                        {
                            VEC_T(1,C)                          vKA = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &vNM);

                            psContact = psPacket->m_psContact + psPacket->m_niContact;

                            psContact->m_vS0 = FCN_V(tgMH_SUB)(&vP2, &vKA);
                            psContact->m_vN0 = vNM;
                            psContact->m_fT0 = TYPE_K(0);
                            psContact->m_fDepth = psCP0->m_fRadius - fTM;

                            ++psPacket->m_niContact;
                        };
                    };
                };
            }
            else
            {
                VEC_T(1,C)                          vK4 = FCN_V(tgMH_SUB)(&vS1, &vS0);
                VAR_T()                             fT0, fT1;
                VAR_T(C)                            fDistSq = FCN_VO(tgCO_F_LR11_ParamSq_LR11)(&fT0, &fT1, &vS0, &vK4, &vEP, &vET);

                if (fDistSq < psCP0->m_fRadiusSq && !FCN_F(tgCM_NR0)(fT1) && !FCN_F(tgCM_NR1)(fT1))
                {
                    /* The closest point on the triangle is not a vertex - and the edge is valid. */

                    if (psPacket->m_niContact >= psPacket->m_niMaxContact)
                    {
                        return (KTgE_MAX_CONTACTS);
                    }
                    else
                    {
                        VAR_T()                             fDist;

                        VEC_T(1,C)                          vKA = FCN_V(tgMH_MUL_SV)(TYPE_K(1) - fT1, &vS0);
                        VEC_T(1,C)                          vKE = FCN_V(tgMH_MUL_SV)(fT1, &vS1);
                        VEC_T(1,C)                          vP0 = FCN_V(tgMH_ADD)(&vKA, &vKE);
                        VEC_T(1,C)                          vKB = FCN_V(tgMH_SUB)(&vP0, &vEP);
                        VEC_T(1,C)                          vKC = FCN_V(tgMH_MUL_SV)(fT1, &vET);
                        VEC_T(1,C)                          vKD = FCN_V(tgMH_ADD)(&vKB, &vKC);
                        VEC_T(1,C)                          vNM = FCN_V(tgMH_NORM_LEN)(&fDist, &vKD);
                        VEC_T(1,C)                          vK5 = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &vNM);

                        psContact = psPacket->m_psContact + psPacket->m_niContact;

                        psContact->m_vS0 = FCN_V(tgMH_SUB)(&vP0, &vK5);
                        psContact->m_vN0 = vNM;
                        psContact->m_fT0 = TYPE_K(0);
                        psContact->m_fDepth = psCP0->m_fRadius - fDist;

                        ++psPacket->m_niContact;
                    };
                };
            };
        };
    };

    return (niContact == psPacket->m_niContact ? KTgE_NO_INTERSECT : KTgS_OK);
}


/* ---- FCN_VO(tgCO_FI_ST_Penetrate_Sphere_Cap_CP) ------------------------------------------------------------------------------------------------------------------------------- */
/* Input:  psPacket: The current series of contact points for this query-series, and contact generation parameters.                                                                */
/* Input:  psCP0: Capsule primitive - contact points are generated on this primitive                                                                                               */
/* Input:  psST0: Space Triangle primitive                                                                                                                                         */
/* Input:  fDist: The minimal distance between the capsule axis (segment) and the triangle                                                                                         */
/* Input:  vP0: Point of closest proximity on the capsule axis between it and the triangle                                                                                         */
/* Output: psPacket: Points of penetration between the two primitives are added to it                                                                                              */
/* Return: Result Code                                                                                                                                                             */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
static TgRESULT FCN_VO(tgCO_FI_ST_Penetrate_Sphere_Cap_CP)( VEC_OBJ_T(STg2_CO_Packet,PC) psPacket, VEC_OBJ_T(TgTUBE,CPC) psCP0, VEC_OBJ_T(TgSTRI,CPC) psST0, VAR_T(C) fDist, VEC_T(1,CPC) pvP0 )
{
    VEC_OBJ_T(STg2_CO_Contact,P)                     psContact;

    /* Check the start cap (origin - axis) for contact generation. */

    if (fDist >= TYPE_K(0))
    {
        if (fDist >= psCP0->m_fRadius)
        {
            return (KTgE_NO_INTERSECT);
        }
        else
        {
            VEC_OBJ_T(STg2_CO_Packet)           sCap_Packet;
            VEC_OBJ_T(STg2_CO_Contact)          sCap_Contact;
            VEC_OBJ_T(TgSPHERE)                 sCap;
            TgRESULT                            iResult;
            VEC_T(1)                            vK0, vK1;

            /* Capsule cap is penetrating the triangle plane with the origin above the plane. Execute the sphere penetration code to generate the contact point for the */
            /* capsule cap.  However, since the caps are hemi-spherical in reality, it is necessary to examine the resultant contact point and make sure that the point */
            /* was not created on the illegal space of the sphere.  This is done by culling points out based on the their contact normal. */

            /* Create contact points for the two end caps. */
            sCap_Packet.m_psContact = &sCap_Contact;
            sCap_Packet.m_fSweepTol = TYPE_K(0);
            sCap_Packet.m_niContact = 0;
            sCap_Packet.m_niMaxContact = 1;

            FCN_VO(tgGM_SP_Init)(&sCap, pvP0, psCP0->m_fRadius);

            iResult = FCN_VO(tgCO_F_ST_Penetrate_SP)(&sCap_Packet, psST0, &sCap);

            vK0 = FCN_V(tgMH_SUB)(&sCap_Contact.m_vS0, pvP0);
            vK1 = FCN_V(tgMH_SUB)(pvP0, &psCP0->m_vOrigin);

            if (TgFAILED( iResult ) || FCN_V(tgMH_DOT)(&vK0, &vK1) <= TYPE_K(0))
            {
                return (KTgE_NO_INTERSECT);
            };

            if (psPacket->m_niContact >= psPacket->m_niMaxContact)
            {
                return (KTgE_MAX_CONTACTS);
            };

            psContact = psPacket->m_psContact + psPacket->m_niContact;

            psContact->m_vS0 = sCap_Contact.m_vS0;
            psContact->m_vN0 = sCap_Contact.m_vN0;
            psContact->m_fT0 = TYPE_K(0);
            psContact->m_fDepth = sCap_Contact.m_fDepth;

            ++psPacket->m_niContact;
            return (KTgS_OK);
        };
    }
    else
    {
        /* Capsule cap lies below the plane.  Thus, the sphere penetration code would have ignored it, so for the capsule it is necessary to deal with this separately. */
        /* In this case only generate a contact point if the cap position is contained inside of the normal extruded space of the triangle.  For this case, the contact */
        /* will only have a normal equal to the triangle's normal. */

        if (!FCN_VO(tgGM_ST_Is_Contained)(psST0, pvP0))
        {
            return (KTgE_NO_INTERSECT);
        };

        if (psPacket->m_niContact >= psPacket->m_niMaxContact)
        {
            return (KTgE_MAX_CONTACTS);
        }
        else
        {
            VEC_T(1,C)                          vK2 = FCN_V(tgMH_MUL_SV)(psCP0->m_fRadius, &psST0->m_sCT.m_sET.m_sPT.m_vNormal);

            psContact = psPacket->m_psContact + psPacket->m_niContact;

            psContact->m_vS0 = FCN_V(tgMH_SUB)(pvP0, &vK2);
            psContact->m_vN0 = psST0->m_sCT.m_sET.m_sPT.m_vNormal;
            psContact->m_fT0 = TYPE_K(0);
            psContact->m_fDepth = psCP0->m_fRadius - fDist;

            ++psPacket->m_niContact;
            return (KTgS_OK);
        };
    };
}



/* =============================================================================================================================================================================== */

#include "TgS COMMON/TgS Common - Base - Defines [Template] [Math].h_inc"
