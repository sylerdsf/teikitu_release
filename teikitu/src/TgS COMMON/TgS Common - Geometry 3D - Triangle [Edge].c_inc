/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/*  »Project«   Teikitu Gaming System (TgS) (∂)
    »File«      TgS Common - Geometry 3D - Triangle [Edge].c_inc
    »Author«    Andrew Aye (mailto: andrew.aye@teikitu.com, https://www.andrew.aye.page)
    »Version«   5.16 / »GUID« 015482FC-A4BD-4E1C-AE49-A30E5728D73A */
/*  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */
/*  Copyright: © 2002-2020, Andrew Aye.  All Rights Reserved.
    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
    the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details. You should have received a copy of the
    GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/* == Common ===================================================================================================================================================================== */

/* ---- FCN_VO(tgGM_ET_Is_Valid) ------------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgBOOL FCN_VO(tgGM_ET_Is_Valid)( VEC_OBJ_T(TgETRI,CPCU) psET1 )
{
    if (!FCN_VO(tgGM_PT_Is_Valid)( &psET1->m_sPT) )
    {
        return (false);
    };

    /* Sanity Check: on the edge size. */

    if (!FCN_V(tgMH_Is_Vector_Valid)(psET1->m_avEdge + 0) || FCN_F(tgCM_NR0)(FCN_V(tgMH_LSQ)(psET1->m_avEdge + 0)))
    {
        return (false);
    };

    if (!FCN_V(tgMH_Is_Vector_Valid)(psET1->m_avEdge + 1) || FCN_F(tgCM_NR0)(FCN_V(tgMH_LSQ)(psET1->m_avEdge + 1)))
    {
        return (false);
    };

    if (!FCN_V(tgMH_Is_Vector_Valid)(psET1->m_avEdge + 2) || FCN_F(tgCM_NR0)(FCN_V(tgMH_LSQ)(psET1->m_avEdge + 2)))
    {
        return (false);
    };

    return (true);
}


/* ---- FCN_VO(tgGM_ET_Support_Point) -------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgVOID FCN_VO(tgGM_ET_Support_Point)( VEC_T(1,P) pvRT, VEC_OBJ_T(TgETRI,CPCU) psET1, VEC_T(1,CPCU) ptvDN )
{
    VAR_T(C)                            fAx_E0 = FCN_V(tgMH_DOT)(ptvDN, psET1->m_avEdge + 0);
    VAR_T(C)                            fAx_E1 = -FCN_V(tgMH_DOT)(ptvDN, psET1->m_avEdge + 2);

    TgGEOM_ASSERT_PARAM(FCN_VO(tgGM_ET_Is_Valid)(psET1) && FCN_V(tgMH_Is_Vector_Valid)(ptvDN));

    if (FCN_F(tgCM_NR0)(fAx_E0) && FCN_F(tgCM_NR0)(fAx_E1))
    {
        VEC_T(1,C)                          vX0 = FCN_V(tgMH_SUB)(psET1->m_avEdge + 0, psET1->m_avEdge + 2);
        VEC_T(1,C)                          vX1 = FCN_V(tgMH_MUL_SV)(VAR_K(KTgTHIRD), &vX0);

        *pvRT = (FCN_V(tgMH_ADD)(psET1->m_sPT.m_avPoint + 0, &vX1));
        return;
    }

    if (!(fAx_E0 < TYPE_K(0)))
    {
        if (fAx_E1 > fAx_E0)
        {
            *pvRT = (FCN_V(tgMH_SUB)(psET1->m_sPT.m_avPoint + 0, psET1->m_avEdge + 2));
            return;
        }
        else
        {
            *pvRT = (FCN_V(tgMH_ADD)(psET1->m_sPT.m_avPoint + 0, psET1->m_avEdge + 0));
            return;
        };
    }
    else if (!(fAx_E1 < TYPE_K(0)))
    {
        *pvRT = (FCN_V(tgMH_SUB)(psET1->m_sPT.m_avPoint + 0, psET1->m_avEdge + 2));
        return;
    };

    *pvRT = psET1->m_sPT.m_avPoint[0];
}


/* ---- FCN_VO(tgGM_ET_Is_Tri_Edge_Ignored) -------------------------------------------------------------------------------------------------------------------------------------- */
/** Edge culling is used in different ways by the different systems.  Sometimes the desired approach is to have an edge included one time even if it's marked to be ignored. For
    instance, during penetration collisions calls it is necessary to ignore an edge in determining the method of separation (normal) but in contact reduction the edge has to be
    considered at least once. */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgBOOL FCN_VO(tgGM_ET_Is_Tri_Edge_Ignored)( VEC_OBJ_T(TgETRI,CPCU) psET1, VAR_T(C) fT0, VAR_T(C) fT1 )
{
    if (FCN_F(tgPM_ABS)(fT1) <= VAR_K(KTgEPS))
    {   /*  Edge generated by vertex 0 and vertex 1 */
        if (psET1->m_avEdge[0].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[0].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[0].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].z <= TYPE_K(0));
        };
    }
    else if (FCN_F(tgPM_ABS)(fT0) <= VAR_K(KTgEPS))
    {   /* Edge generated by vertex 0 and vertex 2 */
        if (psET1->m_avEdge[2].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[2].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[2].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].z <= TYPE_K(0));
        };
    }
    else if (FCN_F(tgPM_ABS)(fT0 + fT1 - TYPE_K(1)) <= VAR_K(KTgEPS))
    {   /*  Edge generated by vertex 1 and vertex 2 */
        if (psET1->m_avEdge[1].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[1].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[1].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].z <= TYPE_K(0));
        };
    };

    TgERROR(false);
    return (false);
}


/* ---- FCN_VO(tgGM_ET_Is_Tri_Edge_Ignored_Code) --------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgBOOL FCN_VO(tgGM_ET_Is_Tri_Edge_Ignored_Code)( VEC_OBJ_T(TgETRI,CPCU) psET1, TgRSIZE_C iEdge )
{
    if (0 == iEdge)
    {   /*  Edge generated by vertex 0 and vertex 1 */
        if (psET1->m_avEdge[0].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[0].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[0].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[0].z <= TYPE_K(0));
        };
    }
    else if (2 == iEdge)
    {   /* Edge generated by vertex 0 and vertex 2 */
        if (psET1->m_avEdge[1].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[1].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[1].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[1].z <= TYPE_K(0));
        };
    }
    else if (1 == iEdge)
    {   /*  Edge generated by vertex 1 and vertex 2 */
        if (psET1->m_avEdge[2].x != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].x <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[2].y != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].y <= TYPE_K(0));
        }
        else if (psET1->m_avEdge[2].z != TYPE_K(0))
        {
            return (psET1->m_avEdge[2].z <= TYPE_K(0));
        };
    };

    TgERROR(false);
    return (false);
}
