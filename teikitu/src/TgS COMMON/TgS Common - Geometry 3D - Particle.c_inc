/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/*  »Project«   Teikitu Gaming System (TgS) (∂)
    »File«      TgS Common - Geometry 3D - Particle.c_inc
    »Author«    Andrew Aye (mailto: andrew.aye@teikitu.com, https://www.andrew.aye.page)
    »Version«   5.16 / »GUID« 015482FC-A4BD-4E1C-AE49-A30E5728D73A */
/*  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */
/*  Copyright: © 2002-2020, Andrew Aye.  All Rights Reserved.
    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
    the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details. You should have received a copy of the
    GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/* == Common ===================================================================================================================================================================== */

/* ---- FCN_VO(tgGM_PC_BA) ------------------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgVOID FCN_VO(tgGM_PC_BA)( VEC_OBJ_T(TgBOXAA,PCU) psBA0, VEC_OBJ_T(TgPARTICLE,CPCU) psPC1, VAR_T(C) fT )
{
    VEC_T(1,C)                          vX0 = *FCN_VO(tgGM_PC_Query_Position)( psPC1 );
    VEC_T(1,C)                          vX1 = FCN_VO(tgGM_PC_Query_Position_Time)( psPC1, fT );

    TgGEOM_ASSERT_PARAM(FCN_VO(tgGM_PC_Is_Valid)(psPC1) && !FCN_F(tgPM_NAN)(fT) && fT >= TYPE_K(0));

    FCN_VO(tgGM_BA_Init_PT)( psBA0, &vX0 );
    FCN_VO(tgGM_BA_Union_PT)( psBA0, &vX1 );

    /* Check for points of inflection during the time interval */

    if (!FCN_F(tgCM_NR0)(psPC1->m_vAccel.x) && psPC1->m_vVel.x * psPC1->m_vAccel.x < TYPE_K(0))
    {
        VAR_T(C)                            fPoI = -psPC1->m_vVel.x / psPC1->m_vAccel.x;

        if (fPoI > TYPE_K(0) && fPoI < fT)
        {
            VAR_T(C) fTMP = psPC1->m_vPos.x + fPoI*psPC1->m_vVel.x + TYPE_K(0,5)*fPoI*fPoI*psPC1->m_vAccel.x;

            FCN_VO(tgGM_BA_Set_MinX)( psBA0, FCN_F(tgPM_FSEL)(fTMP - FCN_VO(tgGM_BA_Query_MinX)(psBA0), FCN_VO(tgGM_BA_Query_MinX)(psBA0), fTMP) );
            FCN_VO(tgGM_BA_Set_MaxX)( psBA0, FCN_F(tgPM_FSEL)(FCN_VO(tgGM_BA_Query_MaxX)(psBA0) - fTMP, FCN_VO(tgGM_BA_Query_MaxX)(psBA0), fTMP) );
        };
    };

    if (!FCN_F(tgCM_NR0)(psPC1->m_vAccel.y) && psPC1->m_vVel.y * psPC1->m_vAccel.y < TYPE_K(0))
    {
        VAR_T(C)                            fPoI = -psPC1->m_vVel.y / psPC1->m_vAccel.y;

        if (fPoI > TYPE_K(0) && fPoI < fT)
        {
            VAR_T(C) fTMP = psPC1->m_vPos.y + fPoI*psPC1->m_vVel.y + TYPE_K(0,5)*fPoI*fPoI*psPC1->m_vAccel.y;

            FCN_VO(tgGM_BA_Set_MinY)( psBA0, FCN_F(tgPM_FSEL)(fTMP - FCN_VO(tgGM_BA_Query_MinY)(psBA0), FCN_VO(tgGM_BA_Query_MinY)(psBA0), fTMP) );
            FCN_VO(tgGM_BA_Set_MaxY)( psBA0, FCN_F(tgPM_FSEL)(FCN_VO(tgGM_BA_Query_MaxY)(psBA0) - fTMP, FCN_VO(tgGM_BA_Query_MaxY)(psBA0), fTMP) );
        };
    };

    if (!FCN_F(tgCM_NR0)(psPC1->m_vAccel.z) && psPC1->m_vVel.z * psPC1->m_vAccel.z < TYPE_K(0))
    {
        VAR_T(C)                            fPoI = -psPC1->m_vVel.z / psPC1->m_vAccel.z;

        if (fPoI > TYPE_K(0) && fPoI < fT)
        {
            VAR_T(C) fTMP = psPC1->m_vPos.z + fPoI*psPC1->m_vVel.z + TYPE_K(0,5)*fPoI*fPoI*psPC1->m_vAccel.z;

            FCN_VO(tgGM_BA_Set_MinZ)( psBA0, FCN_F(tgPM_FSEL)(fTMP - FCN_VO(tgGM_BA_Query_MinZ)(psBA0), FCN_VO(tgGM_BA_Query_MinZ)(psBA0), fTMP) );
            FCN_VO(tgGM_BA_Set_MaxZ)( psBA0, FCN_F(tgPM_FSEL)(FCN_VO(tgGM_BA_Query_MaxZ)(psBA0) - fTMP, FCN_VO(tgGM_BA_Query_MaxZ)(psBA0), fTMP) );
        };
    };
}


/* ---- FCN_VO(tgGM_PC_Project) -------------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgVOID FCN_VO(tgGM_PC_Project)( VAR_T(PCU) ptyMin, VAR_T(PCU) ptyMax, VEC_OBJ_T(TgPARTICLE,CPCU) psPC1, VEC_T(1,CPCU) ptvDN )
{
    VAR_T(C)                            fS_AX = FCN_V(tgMH_DOT)(&psPC1->m_vPos, ptvDN);
    VAR_T(C)                            fV_AX = FCN_V(tgMH_DOT)(&psPC1->m_vVel, ptvDN);
    VAR_T(C)                            fA_AX = FCN_V(tgMH_DOT)(&psPC1->m_vAccel, ptvDN);
    VAR_T()                             fTMP;

    TgGEOM_ASSERT_PARAM(FCN_VO(tgGM_PC_Is_Valid)(psPC1) && FCN_V(tgMH_Is_Vector_Valid)(ptvDN));

    *ptyMin = *ptyMax = fS_AX;

    fTMP = fS_AX + fV_AX + TYPE_K(0,5) * fA_AX;
    if (fTMP < *ptyMin)
    {
        *ptyMin = fTMP;
    }
    else if (fTMP > *ptyMax)
    {
        *ptyMax = fTMP;
    };

    /* Check for points of inflexion during the time interval */

    if (!FCN_F(tgCM_NR0)(fA_AX) && fV_AX * fA_AX < TYPE_K(0))
    {
        VAR_T(C)                            fPoI = -fV_AX / fA_AX;

        if (fPoI > TYPE_K(0) && fPoI < TYPE_K(1))
        {
            fTMP = fS_AX + fPoI * fV_AX + TYPE_K(0,5) * fPoI * fPoI * fA_AX;

            if (fTMP < *ptyMin)
            {
                *ptyMin = fTMP;
            }
            else if (fTMP > *ptyMax)
            {
                *ptyMax = fTMP;
            };
        };
    };
}
