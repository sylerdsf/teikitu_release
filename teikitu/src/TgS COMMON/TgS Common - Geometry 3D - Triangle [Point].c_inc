/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/*  »Project«   Teikitu Gaming System (TgS) (∂)
    »File«      TgS Common - Geometry 3D - Triangle [Point].c_inc
    »Author«    Andrew Aye (mailto: andrew.aye@teikitu.com, https://www.andrew.aye.page)
    »Version«   5.16 / »GUID« 015482FC-A4BD-4E1C-AE49-A30E5728D73A */
/*  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ */
/*  Copyright: © 2002-2020, Andrew Aye.  All Rights Reserved.
    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
    the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details. You should have received a copy of the
    GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>. */
/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
/* == Common ===================================================================================================================================================================== */

/* ---- FCN_VO(tgGM_PT_Is_Valid) ------------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgBOOL FCN_VO(tgGM_PT_Is_Valid)( VEC_OBJ_T(TgPTRI,CPCU) psPT1 )
{
    VEC_T(1)                     atvEdge[2], vNormal;

    /* Sanity Check: Vector form. */
    if (!FCN_V(tgMH_Is_Point_Valid)(psPT1->m_avPoint + 0))
    {
        return (false);
    };

    if (!FCN_V(tgMH_Is_Point_Valid)(psPT1->m_avPoint + 1))
    {
        return (false);
    };

    if (!FCN_V(tgMH_Is_Point_Valid)(psPT1->m_avPoint + 2))
    {
        return (false);
    };

    if (!FCN_V(tgMH_Is_Vector_Valid)(&psPT1->m_vNormal) || !FCN_F(tgCM_NR1)(FCN_V(tgMH_LSQ)(&psPT1->m_vNormal)))
    {
        return (false);
    };

    atvEdge[0] = FCN_V(tgMH_SUB)(psPT1->m_avPoint + 1, psPT1->m_avPoint + 0);
    atvEdge[1] = FCN_V(tgMH_SUB)(psPT1->m_avPoint + 2, psPT1->m_avPoint + 0);

    /* Sanity Check: on the edge size. */

    if (FCN_F(tgCM_NR0)(FCN_V(tgMH_LSQ)(atvEdge + 0)) || FCN_F(tgCM_NR0)(FCN_V(tgMH_LSQ)(atvEdge + 1)))
    {
        return (false);
    };

    /* Sanity check on the "aspect" ratio of the triangle - remember that |a x b| = |a|•|b|•|sin(Θ)|, and near zero sin(Θ) ≈ Θ */

    vNormal = FCN_V(tgMH_CX)(atvEdge + 0, atvEdge + 1);

    if (FCN_V(tgMH_LSQ)( &vNormal ) < VAR_K(KTgEPS) * FCN_V(tgMH_LSQ)( atvEdge + 0 ) * FCN_V(tgMH_LSQ)( atvEdge + 1 ))
    {
        return (false);
    };

    return (true);
}


/* ---- FCN_VO(tgGM_PT_Support_Point) -------------------------------------------------------------------------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
TgVOID FCN_VO(tgGM_PT_Support_Point)( VEC_T(1,P) pvRT, VEC_OBJ_T(TgPTRI,CPCU) psPT1, VEC_T(1,CPCU) ptvDN )
{
    VAR_T(C)                            fAx_N = FCN_V(tgMH_DOT3)(ptvDN, &psPT1->m_vNormal);

    TgGEOM_ASSERT_PARAM(FCN_VO(tgGM_PT_Is_Valid)(psPT1) && FCN_V(tgMH_Is_Vector_Valid)(ptvDN));

    if (FCN_F(tgCM_NR0)(fAx_N - TYPE_K(1)))
    {
        *pvRT = (FCN_V(tgMH_SETP_S)(
            VAR_K(KTgTHIRD) * (psPT1->m_avPoint[0].x + psPT1->m_avPoint[1].x + psPT1->m_avPoint[2].x),
            VAR_K(KTgTHIRD) * (psPT1->m_avPoint[0].y + psPT1->m_avPoint[1].y + psPT1->m_avPoint[2].y),
            VAR_K(KTgTHIRD) * (psPT1->m_avPoint[0].z + psPT1->m_avPoint[1].z + psPT1->m_avPoint[2].z)
            ));
    }
    else
    {
        VAR_T(C)                            fAx_P0 = FCN_V(tgMH_DOT3)(ptvDN, psPT1->m_avPoint + 0);
        VAR_T(C)                            fAx_P1 = FCN_V(tgMH_DOT3)(ptvDN, psPT1->m_avPoint + 1);
        VAR_T(C)                            fAx_P2 = FCN_V(tgMH_DOT3)(ptvDN, psPT1->m_avPoint + 2);

        if (fAx_P0 > fAx_P1)
        {
            if (fAx_P0 > fAx_P2)
            {
                *pvRT = (psPT1->m_avPoint[0]);
            }
            else
            {
                *pvRT = (psPT1->m_avPoint[2]);
            };
        }
        else
        {
            if (fAx_P1 > fAx_P2)
            {
                *pvRT = (psPT1->m_avPoint[1]);
            }
            else
            {
                *pvRT = (psPT1->m_avPoint[2]);
            };
        };
    };
}
